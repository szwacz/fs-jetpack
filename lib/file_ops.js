// Simple operations on a file: read, write, append.

"use strict";

var fs = require('fs');
var Q = require('q');
var mkdirp = require('mkdirp');
var pathUtil = require('path');

// Temporary file extensions used for atomic file overwriting.
var newExt = ".__new__";

// Matches strings generated by Date.toJSON()
// which is called to serialize date to JSON.
var jsonDateParser = function (key, value) {
    var reISO = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*))(?:Z|(\+|-)([\d|:]*))?$/;
    if (typeof value === 'string') {
        if (reISO.exec(value)) {
            return new Date(value);
        }
    }
    return value;
};

var processDataToWrite = function (data, options) {
    // If data is a s simple object convert it to JSON.
    if (typeof data === 'object'
        && !Buffer.isBuffer(data)
        && data !== null) {
        var indent = options.jsonIndent;
        if (typeof indent !== 'number') {
            indent = 2;
        }
        data = JSON.stringify(data, null, indent);
    }

    return data;
};

var makeNicerJsonParsingError = function (path, err) {
    var nicerError = new Error('JSON parsing failed while reading '
        + path + ' [' + err + ']');
    nicerError.originalError = err;
    return nicerError;
};

// ---------------------------------------------------------
// SYNC
// ---------------------------------------------------------

var readSync = function (path, returnAs) {
    returnAs = returnAs || 'utf8';

    var encoding = 'utf8';
    if (returnAs === 'buf') {
        encoding = null;
    }

    var data;
    try {
        data = fs.readFileSync(path, { encoding: encoding });
    } catch (err) {
        if (err.code === 'ENOENT') {
            // If file doesn't exist just return null, no need to throw
            data = null;
        } else {
            // Otherwise rethrow the error
            throw err;
        }
    }

    try {
        if (returnAs === 'json') {
            data = JSON.parse(data);
        } else if (returnAs === 'jsonWithDates') {
            data = JSON.parse(data, jsonDateParser);
        }
    } catch (err) {
        throw makeNicerJsonParsingError(path, err);
    }

    return data;
};

var writeFileSync = function (path, data, options) {
    try {
        fs.writeFileSync(path, data, options);
    } catch (err) {
        if (err.code === 'ENOENT') {
            // Means parent directory doesn't exist, so create it and try again.
            mkdirp.sync(pathUtil.dirname(path));
            fs.writeFileSync(path, data, options);
        } else {
            throw err;
        }
    }
};

var writeAtomicSync = function (path, data, options) {
    // we are assuming there is file on given path, and we don't want
    // to touch it until we are sure our data has been saved correctly,
    // so write the data into temporary file...
    writeFileSync(path + newExt, data, options);
    // ...next rename temp file to replace real path.
    fs.renameSync(path + newExt, path);
};

var writeSync = function (path, data, options) {
    options = options || {};
    data = processDataToWrite(data, options);

    var writeStrategy = writeFileSync;
    if (options.atomic) {
        writeStrategy = writeAtomicSync;
    }
    writeStrategy(path, data, { mode: options.mode });
};

var appendSync = function (path, data, options) {
    try {
        fs.appendFileSync(path, data, options);
    } catch (err) {
        if (err.code === 'ENOENT') {
            // Parent directory doesn't exist,
            // so just create it and write the file.
            writeFileSync(path, data, options);
        } else {
            throw err;
        }
    }
};

// ---------------------------------------------------------
// ASYNC
// ---------------------------------------------------------

var promisedReadFile = Q.denodeify(fs.readFile);
var promisedRename = Q.denodeify(fs.rename);
var promisedWriteFile = Q.denodeify(fs.writeFile);
var promisedAppendFile = Q.denodeify(fs.appendFile);
var promisedMkdirp = Q.denodeify(mkdirp);

var readAsync = function (path, returnAs) {
    var deferred = Q.defer();

    returnAs = returnAs || 'utf8';

    var encoding = 'utf8';
    if (returnAs === 'buf') {
        encoding = null;
    }

    promisedReadFile(path, { encoding: encoding })
    .then(function (data) {
        // Make final parsing of the data before returning.
        try {
            if (returnAs === 'json') {
                data = JSON.parse(data);
            } else if (returnAs === 'jsonWithDates') {
                data = JSON.parse(data, jsonDateParser);
            }
            deferred.resolve(data);
        } catch (err) {
            deferred.reject(makeNicerJsonParsingError(path, err));
        }
    })
    .catch(function (err) {
        if (err.code === 'ENOENT') {
            // If file doesn't exist just return null,
            // no need to raise an error.
            deferred.resolve(null);
        } else {
            // Otherwise throw
            deferred.reject(err);
        }
    });

    return deferred.promise;
};

var writeFileAsync = function (path, data, options) {
    var deferred = Q.defer();

    promisedWriteFile(path, data, options)
    .then(deferred.resolve)
    .catch(function (err) {
        // First attempt to write a file ended with error.
        // Check if this is not due to nonexistent parent directory.
        if (err.code === 'ENOENT') {
            // Parent directory doesn't exist, so create it and try again.
            promisedMkdirp(pathUtil.dirname(path))
            .then(function () {
                return promisedWriteFile(path, data, options);
            })
            .then(deferred.resolve, deferred.reject);
        } else {
            // Nope, some other error, throw it.
            deferred.reject(err);
        }
    });

    return deferred.promise;
};

var writeAtomicAsync = function (path, data, options) {
    var deferred = Q.defer();

    // We are assuming there is file on given path, and we don't want
    // to touch it until we are sure our data has been saved correctly,
    // so write the data into temporary file...
    writeFileAsync(path + newExt, data, options)
    .then(function () {
        // ...next rename temp file to real path.
        return promisedRename(path + newExt, path);
    })
    .then(deferred.resolve, deferred.reject);

    return deferred.promise;
};

var writeAsync = function (path, data, options) {
    options = options || {};
    data = processDataToWrite(data, options);

    var writeStrategy = writeFileAsync;
    if (options.atomic) {
        writeStrategy = writeAtomicAsync;
    }
    return writeStrategy(path, data, { mode: options.mode });
};

var appendAsync = function (path, data, options) {
    var deferred = Q.defer();

    promisedAppendFile(path, data, options)
    .then(deferred.resolve, function (err) {

        if (err.code === 'ENOENT') {
            // If parent directory doesn't exist create it.
            promisedMkdirp(pathUtil.dirname(path))
            .then(function () {
                return appendAsync(path, data, options);
            })
            .then(deferred.resolve, deferred.reject);
        } else {
            deferred.reject(err);
        }

    });

    return deferred.promise;
};

// ---------------------------------------------------------
// API
// ---------------------------------------------------------

module.exports.read = readSync;
module.exports.write = writeSync;
module.exports.append = appendSync;

module.exports.readAsync = readAsync;
module.exports.writeAsync = writeAsync;
module.exports.appendAsync = appendAsync;
